import {useContext, useEffect, useRef, useState} from 'react';

import {PhaseContext, HYDRATION, SERVER} from './context';
import {noContext, noImmediateStateOnHydrationError, noImmediateStateOnRenderError, noImmediateStateOnServerError} from './errors';

/**
 * <code>useWidgetState</code> is a React hook that provides a widget's state
 * within a React component parented by the widget.
 *
 * Widgets can be nested, so the widget whose state is required is specified by
 * its React context.
 *
 * If the component is not inside the widget, an error will be logged and an
 * empty object returned.
 *
 * If the widget doesn't immediately (and synchronously) produce a value on the
 * first client-side render, an error will be logged and an empty object
 * returned.
 *
 * To avoid unnecessary re-renders, provide a comparison function that returns
 * <code>true</code> if, and only if, its first two arguments are equal.
 * Alternatively, provide an array of the names of the properties to shallow-
 * compare between two consecutive widget states.
 *
 * @example
 *
 * // Get foo and bar from someWidget's state and re-render this component when
 * // foo and/or bar changes, based on === comparison.
 * const {foo, bar} = useWidgetState(someWidgetContext, ['foo', 'bar']);
 *
 * @example
 *
 * // As above, but doing it the hard way.
 * const {foo, bar} = useWidgetState(
 *     someWidgetContext,
 *     (a, b) => a.foo === b.foo && a.bar === b.bar
 * );
 *
 * @param {Object} context - a widget's context
 * @param {Function|string[]} [compare] - the widget state comparison or list of its properties to compare
 * @returns {Object} the widget's state.
 */
export default function useWidgetState(context, compare) {
    const phase = useContext(PhaseContext)();

    if (phase === SERVER) {
        const {data$, name} = useContext(context);
        const [state] = useState(() => {
            let immediateState = null;

            // Subscribe and unsubscribe to get an immediate value from the stream.
            // If we're *really* server-side, data$ is generated by bacon.constant from the initial value produced by
            // getData when it eventually resolves, so this should *always* produce initial state.
            // Nevertheless, it's possible not to have an initial state according to the explanation in the error
            // message a few lines down.
            data$.onValue((value) => {
                immediateState = value;
            })();

            if (process.env.NODE_ENV === 'development' && !immediateState) {
                console.error(noImmediateStateOnServerError(name));
            }

            return immediateState;
        });

        return state;
    } else {
        const {data$, name, elementId} = (useContext(context) || {});
        const subscription = useRef(null);

        let immediateState = null;

        // On the first event (which should be immediate), set the immediate value.
        const observer = useRef((value) => {
            immediateState = value;
        });

        const [state, setState] = useState(() => {
            // If we're not in the context's scope, log an error and move on.
            if (!data$) {
                console.error(noContext());

                // Default to {} so errors aren't thrown when destructuring the result of useWidgetState(context)
                return {};
            }

            subscription.current = withSkipDuplicates(data$, compare).onValue((value) => {
                observer.current(value);
            });

            if (!immediateState) {
                if (process.env.NODE_ENV === 'development') {
                    if (phase === HYDRATION) {
                        // This is more severe on hydration than pure client-side rendering, because it will cause a hydration mismatch. The
                        // hydration object provided to getData should have sufficient data to product the first event immediately.
                        console.error(noImmediateStateOnHydrationError(name, elementId));
                    } else {
                        // This is less severe on pure client-side rendering than when hydrating. Nevertheless, it's a bad idea to render a
                        // component without props - even as an implicit loading state - when it expects props.
                        console.warn(noImmediateStateOnRenderError(name));
                    }
                }
            }

            // On subsequent events (or the initial event if it wasn't produced immediately), update the state.
            observer.current = (value) => {
                setState(value);
            };

            // In case there is no immediate state, default to {} so errors aren't thrown when destructuring the result of useWidgetState(context)
            return immediateState || {};
        });

        // Unsubscribe
        useEffect(() => () => {
            if (subscription.current) {
                subscription.current();
            }
        }, []);

        return state;
    }
}

// If compare is a function, return data$ with its duplicates skipped based on the function.
// If compare is an array, return data$ with duplicates skipped based on equality of the properties specified in the array.
// Otherwise, return data$ as is.
function withSkipDuplicates(data$, compare) {
    if (typeof compare === 'function') {
        return compare;
    }

    if (Array.isArray(compare)) {
        return data$.skipDuplicates((a = {}, b = {}) => compare.every((property) => a[property] === b[property]));
    }

    return data$;
}

import {Property, Sink, Unsub} from 'baconjs'
import React, {useContext, useEffect, useRef, useState} from 'react'

import PhaseContext from './context/PhaseContext'
import PhaseContextType from './context/PhaseContextType'
import {noContext, noImmediateStateOnServerError} from './errors'
import Phase from './Phase'
import {CompareWidgetState, WidgetContext} from './types'

/**
 * <code>useWidgetState</code> is a React hook that provides a widget's state
 * within a React component parented by the widget.
 *
 * Widgets can be nested, so the widget whose state is required is specified by
 * its React context.
 *
 * If the component is not inside the widget, an error will be logged and an
 * empty object returned.
 *
 * If the widget doesn't immediately (and synchronously) produce a value on the
 * first client-side render, an error will be logged and an empty object
 * returned.
 *
 * To avoid unnecessary re-renders, provide a comparison function that returns
 * <code>true</code> if, and only if, its first two arguments are equal.
 * Alternatively, provide an array of the names of the properties to shallow-
 * compare between two consecutive widget states.
 *
 * @example
 *
 * // Get foo and bar from someWidget's state and re-render this component when
 * // foo and/or bar changes, based on === comparison.
 * const {foo, bar} = useWidgetState(someWidgetContext, ['foo', 'bar'])
 *
 * @example
 *
 * // As above, but doing it the hard way.
 * const {foo, bar} = useWidgetState(
 *     someWidgetContext,
 *     (a, b) => a.foo === b.foo && a.bar === b.bar
 * )
 *
 * @param context - a widget's context
 * @param [compare] - the widget state comparison or list of its properties to compare
 * @returns the widget's state and a loading state.
 */
export default function useWidgetState<STATE>(
    context: React.Context<WidgetContext<STATE>>,
    compare?: CompareWidgetState<STATE>
): [STATE, false] | [undefined, true] {
    const phase = useContext<PhaseContextType>(PhaseContext)()

    if (phase === Phase.server) {
        const {state$, name} = useContext<WidgetContext<STATE>>(context)
        const [state] = useState<STATE>(() => {
            let immediateState: STATE | undefined

            // Subscribe and unsubscribe to get an immediate value from the stream.
            // If we're *really* server-side, state$ is generated by bacon.constant from the initial value produced by
            // stream when it eventually resolves, so this should *always* produce initial state.
            // Therefore, this should *absolutely* not happen.
            state$.onValue((value: STATE) => {
                immediateState = value
            })()

            if (process.env.NODE_ENV === 'development' && !immediateState) {
                throw new Error(noImmediateStateOnServerError(name))
            }

            return immediateState! // eslint-disable-line @typescript-eslint/no-non-null-assertion
        })

        return [
            state,
            false, // Don’t render the loading state server-side
        ]
    } else {
        const {state$} = (useContext<WidgetContext<STATE>>(context) || {})
        const subscription = useRef<Unsub>()

        let initialState: STATE | undefined

        // On the first event, set the immediate value.
        // NOTE: The first event is guaranteed to be emitted immediately.
        const observer = useRef<Sink<STATE>>((value: STATE) => {
            initialState = value
        })

        const [state, setState] = useState<STATE | undefined>(() => {
            // Ensure we're in the context's scope.
            if (!state$) {
                throw new Error(noContext())
            }

            subscription.current = withSkipDuplicates<STATE>(state$, compare).onValue((value: STATE) => {
                // On the first event, if fired synchronously, set the initial state synchronously to avoid the loading state.
                observer.current(value)
            })

            // On subsequent events (or the initial event if it wasn't produced immediately), update the state.
            observer.current = (value: STATE) => {
                setState(value)
            }

            // The initial state comes from the first state event if fired synchronously.
            // The first state event should be synchronous when hydrating and on SSR.
            // The first state event is not necessarily synchronous on pure client-side rendering.
            return initialState
        })

        // Unsubscribe
        useEffect(() => () => {
            if (subscription.current) {
                subscription.current()
            }
        }, [])

        // A bit verbose because type guards aren’t smart enough for [state, state === undefined]
        return state === undefined
            ? [undefined, true]
            : [state, false]
    }
}

// If compare is a function, return state$ with its duplicates skipped based on the function.
// If compare is an array, return state$ with duplicates skipped based on equality of the properties specified in the array.
// Otherwise, return state$ as is.
function withSkipDuplicates<STATE>(state$: Property<STATE>, compare?: CompareWidgetState<STATE>): Property<STATE> {
    if (typeof compare === 'function') {
        return state$.skipDuplicates(compare)
    }

    type C = STATE

    if (Array.isArray(compare)) {
        return state$.skipDuplicates((a = {} as C, b = {} as C) => compare.every((property: keyof (STATE)) => a[property] === b[property]))
    }

    return state$
}
